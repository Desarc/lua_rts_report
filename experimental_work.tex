\chapter{Experimental Work}
\label{ch:experimental_work}
This chapter describes the experimental work done as part of the project. Since it is a rather incremental process, the goal, procedure and relevant results are described individually in each section.

\section{Implementation of a Runtime Support System for State Machines in Lua}
\label{sec:impl_runtime_support}
The first step towards working with state machine -based applications, is building a runtime system for a collection of generalized state machines. For the experimental purposes of this project, a runtime system with only the most basic functionality is needed. The components required for this are:

\begin{itemize}
	\item An \guillemotleft event\guillemotright data structure for handling messages to and between state machines
	\item A \guillemotleft timer\guillemotright object for keeping track of timed events
	\item A prototype/\gls{api} for state machines
	\item A \guillemotleft scheduler\guillemotright to keep track of active state machines, events and timers, and assigning events and timers to their respective state machines at the appropriate time.
\end{itemize}

It turns out to be quite simple to implement this system in Lua. The source code is included in Appx.~\ref{code:rts}, and each component is explained in the sections below.

\subsection{Event Data Structure}
\label{sec:impl_event}
Even though Lua is not natively object-oriented, an event object is still easily implemented by use of the \_\_index metamethod~\cite[13.4.1]{book:programming_in_lua_first}. We simply create a prototype for the event object with the desired fields (ID of state machine, event type and additional data) and methods (constructor, setters and getters). Inheritance is then enabled by creating an empty table/object, and setting its \_\_index to reference the parent object's fields. Lua doesn't support encapsulation by conventional means~\cite[16.4]{book:programming_in_lua_first}, but rather by creating \emph{closures}. Encapsulated fields may then only be accessed by functions declared in the same local scope, as seen in the constructor method for event (\emph{Event:new}, Code Snip.~\ref{code:event}). This is useful also in a state machine context to avoid inadvertent or even malicious tampering with event data or state of state machines. Combined, these approaches make the event data structure simple, safe and easy to use.

\subsection{Timer Object}
\label{sec:impl_timer}
The timer object (Code Snip.~\ref{code:timer}) is created similarly to the event object described in Sect.~\ref{sec:impl_event} with respect to inheritance and encapsulation. Additionally, we need some way to keep track of time. As discussed in Sect.~\ref{sec:lua_and_state_machines}, Lua does not natively offer preemptive multitasking, so running an active timer on a separate thread is pretty much out of the question. However, for a simple runtime system, we may delegate the responsibility of measuring time to the scheduler component, and simply create a \guillemotleft timestamp\guillemotright for the desired activation time. This may decrease the timing accuracy of activation, but on the other hand also decreases overhead and complexity of the runtime system. In many cases it is not necessary or even desirable to preempt a running transition, but sufficient to wait until the transition has finished before scheduling the event following the timeout. This is however something that should be addressed when designing a more complete runtime system, and something that may prove challenging, as discussed in Sect.~\ref{sec:lua_and_state_machines}.

The granularity of the timestamp is another issue that must be addressed, and is also discussed in Sect.~\ref{sec:lua_and_state_machines}. As a starting point, I chose to use \emph{os.time()}, even though it only offers \emph{second}-granularity. This is OK for the preliminary examples, and further addressed in Sect.~\ref{sec:running_on_micro}.

\subsection{State Machine Prototype/API}
The third component we need is a prototype for implementation of a given state machine. This prototype serves as a kind of API, defining some common values and methods for all state machines. The state machine prototype (Code Snip.~\ref{code:stm}), inspired by an exercise given in the course TTM4160 at NTNU, contains some predefined values to be returned to the scheduler after a transition, encapsulated data fields for state and ID, as well as a \guillemotleft fire\guillemotright function meant to be overridden in an implementation. Additionally, the required presence of a \guillemotleft run\guillemotright field holding a coroutine is indicated. This is further discussed in Sect~\ref{sec:impl_sched}.

\subsection{Scheduler}
\label{sec:impl_sched}
The scheduler (Code Snip.~\ref{)


\section{Implementation of Simple State Machines in Lua}
\label{sec:impl_state_machines}

\section{Running the State Machine -based Application on a Microcontroller}
\label{sec:running_on_micro}

\subsection{The LM3S9D92 Microcontroller}

\subsection{Running eLua on the Evaluation Kit Board}

\subsection{Running the Simple Application}

\section{Measurements of RTS Overhead}
\label{sec:overhead_measure}

\begin{listing}[H]
\begin{luacode}
local task_size = 10
local task_repeats = 1

local function busy_work()
	for i=1,task_size do
		q = i*i
	end
end

local start_time = tmr.read(tmr.SYS_TIMER)

for j=1,task_repeats do
	busy_work()
end

local delta = tmr.read(tmr.SYS_TIMER) - start_time
print("Delta: "..tostring(delta))
\end{luacode}
	\caption{Lua code used for overhead testing}
	\label{code:overhead}
\end{listing}

\section{Measurements of Application Performance}
\label{sec:performance_measure}

\section{A More Complex Application}
\label{sec:impl_complex_app}
