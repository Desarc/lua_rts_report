\chapter{Experimental work}
\label{ch:experimental_work}
This chapter describes the experimental work done as part of the project. Since it is a rather incremental process, the goal, procedure and relevant results are described individually in each section.

\section{Implementation of a runtime support system for state machines in Lua}
\label{sec:impl_runtime_support}
The first step towards working with state machine -based applications, is building a runtime system for a collection of generalized state machines. For the experimental purposes of this project, a runtime system with only the most basic functionality is needed. The components required for this are:

\begin{itemize}
	\item An ‘event’ data structure for handling messages to and between state machines
	\item A ‘timer’ object for keeping track of timed events
	\item A prototype/\gls{api} for state machines
	\item A 'scheduler' to keep track of active state machines, events and timers, and assigning events and timers to their respective state machines at the appropriate time.
\end{itemize}

It turns out to be quite simple to implement this system in Lua. The source code is included in appendix \ref{code:rts}, and each component is explained in the sections below.

\subsection{Event data structure}
\label{sec:impl_event}
Even though Lua is not natively object-oriented, an Event object is still easily implemented by use of the \_\_index metamethod \cite[13.4.1]{book:programming_in_lua_first}. We simply create a prototype for the Event object with the desired fields (ID of state machine, event type and additional data) and methods (constructor, setters and getters). Inheritance is then enabled by creating an empty table/object, and setting its \_\_index to reference the parent object's fields. Lua doesn't support encapsulation by conventional means \cite[16.4]{book:programming_in_lua_first}, but rather by creating \textit{closures}. Encapsulated fields may then only be accessed by functions declared in the same local scope, as seen in the constructor method for Event (\textit{Event:new}, code snippet \ref{code:event}). This is useful also in a state machine context to avoid inadvertent or even malicious tampering with event data or state of state machines. Combined, these approaches make the Event data structure simple, safe and easy to use.

\subsection{Timer object}
\label{sec:impl_timer}
The Timer object (code snippet \ref{code:timer}) is created similarly to the Event object described in section \ref{sec:impl_event} with respect to inheritance and encapsulation. Additionally, we need some way to keep track of time. As discussed in section \ref{sec:lua_and_state_machines}, Lua does not natively offer preemptive multitasking, so running an active timer on a separate thread is pretty much out of the question. However, for a simple runtime system, we may delegate the responsibility of measuring time to the scheduler component, and simply create a 'timestamp' for the desired activation time. This may decrease the timing accuracy of activation, but on the other hand also decreases overhead and complexity of the runtime system. In many cases it is not necessary or even desirable to preempt a running transition, but sufficient to wait until the transition has finished before scheduling the event following the timeout. This is however something that should be addressed when designing a more complete runtime system, and something that may prove challenging, as discussed in section \ref{sec:lua_and_state_machines}.

The granularity of the timestamp is another issue that must be addressed, and is also discussed in section \ref{sec:lua_and_state_machines}. As a starting point, I chose to use \textit{os.time()}, even though it only offers \textit{second}-granularity. This is OK for the preliminary examples, and further addressed in section \ref{sec:running_on_micro}.

\subsection{State machine prototype/API}
The third component we need is a prototype for implementation of a given state machine. This prototype serves as a kind of API, defining some common values and methods for all state machines. The StateMachine prototype (code snippet \ref{code:stm}), inspired by an exercise given in the course TTM4160 at NTNU, contains some predefined values to be returned to the scheduler after a transition, encapsulated data fields for state and ID, as well as a 'fire' function meant to be overridden in an implementation. Additionally, the required presence of a 'run' field holding a coroutine is indicated. This is further discussed in section \ref{sec:impl_sched}.

\subsection{Scheduler}
\label{sec:impl_sched}


\section{Implementation of simple state machines in Lua}
\label{sec:impl_state_machines}

\section{Running the state machine based application on a microcontroller}
\label{sec:running_on_micro}

\subsection{The LM3S9D92 microcontroller}

\subsection{Running eLua on the evaluation kit board}

\subsection{Running the simple application}

\section{Measurements of RTS overhead}
\label{sec:overhead_measure}

\begin{listing}[H]
\begin{luacode}
local task_size = 10
local task_repeats = 1
local measurements = 5

local function busy_work()
	for i=1,task_size do
		q = i*i
	end
end

for i=1,measurements do
	local start_time = tmr.read(tmr.SYS_TIMER)

	for j=1,task_repeats do
		busy_work()
	end

	local delta = tmr.read(tmr.SYS_TIMER) - start_time
	print("Delta: "..tostring(delta))
end
\end{luacode}
	\caption{Lua code used for overhead testing}
	\label{code:overhead}
\end{listing}

\section{Measurements of application performance}
\label{sec:performance_measure}

\section{A more complex application}
\label{sec:impl_complex_app}
