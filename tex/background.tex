\chapter{Background}
\label{chp:background}

\section{The Lua programming language}
\label{sec:lua}

\subsection{Lua basics}
\label{sec:lua_basics}
The Lua programming language is a dynamic, multi-paradigm scripting language developed at the Pontifical Catholic University of Rio de Janeiro.

While Lua was designed as an extension scripting language, it is still possible to execute standalone Lua programs through the Lua interpreter.

\subsection{Why Lua?}
\label{sec:why_lua}
There are many other programming languages that are valid and may be used for state machine implementations. What makes Lua special?

\paragraph{Memory footprint}
The standard Lua core was purposefully designed to be minimalistic, offering only a base set of functions \cite{Ierusalimschy:the_implementation_of_lua}. As a result of this, the extra memory used, by either adding Lua to your application (extending) or running the code through the Lua interpreter, is minimal. The Lua interpreter built with the standard libraries requires only a total of 182K memory on Linux \cite{website:lua_about}. This is an important property, especially when working with embedded systems, where memory capabilities are usually severely restricted. Lua thus allows for high-level application scripting without adding much overhead.

\paragraph{Speed}
Lua is considered to be one of the fastest available scripting languages, and independent benchmarks support this claim \cite{website:lua_performance_tests}. Speed versus memory usage is a common trade-off in computer systems, and this is highly relevant for embedded real-time systems, where both memory and speed have restricting limits. It is unlikely that Lua performance can (on average) match that of a fully compiled language like Java or C++ on any architecture, but relatively good performance combined with a low memory cost and low complexity makes Lua a possible middle-option.

The performance of Lua may be further increased with LuaJIT (however at a slightly increased memory cost). LuaJIT is an independently maintained Just-In-Time Compiler for Lua, whose purpose is to increase Lua performance by compiling (and caching) Lua code to machine code (as opposed to bytecode, which is what the standard Lua interpreter does). LuaJIT has been shown to increase Lua performance by significant factors for single threaded programs on various processors \cite{website:luajit}. 

\paragraph{Portability}
The Lua interpreter is written in standard ANSI C (actually "clean C", which is the subset of C that is compatible with C++, or vice versa). This means the interpreter can be compiled and built out-of-the-box on any platform with a standard C compiler, and may similarly be adapted and cross-compiled also to run on even more platforms. The Lua core has been deliberately designed to allow for portability to "unsupported" platforms with minimal changes to its code \cite[ch. 26]{book:lua_gems}. With a working Lua interpreter, any standard Lua program will work for the given platform.

\paragraph{Embedding}
In addition to the Lua interpreter itself being portable, Lua is easy to embed into applications written in other languages. Similarly, Lua may be extended with libraries written in other languages. Lua is actually designed to be an extension language, and this area also accounts for most of its use \cite{website:where_lua_is_used}. Lua is particularly refined for working with C, providing a robust and flexible C API. This means that functionality that may be inconvenient to implement in Lua (e.g. I/O handling on a microcontroller) can be added through a C library, with relative ease. Alternatively, a state machine based application may consist of a C runtime system, with the state machines and application logic defined in Lua.

\paragraph{Sandboxing}
In Lua, functions are first-class values. Additionally, references to the standard library functions are stored in variables in the Lua global environment. Whenever a globally defined function is called, Lua looks it up in the global environment table. If we wish to restrict access to certain functions, the table entry may be replaced by a different function, performing some checking before access to the actual (renamed) library function is given. In a state machine system, this could be useful if we want to allow the execution of arbitrary state machines, and allows us to implement safety and security with relative ease. Additionally, memory and CPU usage can be limited by use of the standard Lua debugging library \cite{book:lua_reference_manual}.

\paragraph{Collaborative multitasking}
Lua supports multitasking in the form of coroutines, which is collaborative (non-preemptive). Coroutines do not run in parallel on a processor, but explicitly yield control of the processor to each other. The purpose of collaborative multitasking is to structure programs in clearer and more restrictive ways, for better internal control. Each coroutine is an independent thread with its own stack, but memory may be shared between threads. This is ideal for a state machine based application: the scheduler may yield control of the processor to a state machine, who will continue execution based on the state of its own stack. When an event has been processed, the state machine simply resumes control of the processor to the scheduler.

\paragraph{Complexity}
One of the goals of Lua is to be simple, without being simplistic \cite{Ierusalimschy:the_implementation_of_lua}. It is fairly easy for less experienced programmers to read and use Lua, allowing users to add functionality without having to learn all the underlying quirks. At the same time, the Lua meta-mechanisms allow for more complex and powerful use of the language, resulting in support for additional paradigms (like object-oriented programming).

\subsection{Why \textbf{not} Lua?}
\label{sec:why_not_lua}
While there are many arguments that speak in favor of exploring Lua for state machine based systems, there are also some apparent limitations.

\paragraph{Multitasking}
Lua offers non-preemptive multitasking, which is probably sufficient in most cases for an extension language. However, if we want a pure Lua state machine runtime support system, preemptive multitasking may to some degree be necessary, e.g. in order to handle I/O (often resulting in external events that should be added to some event queue).

\paragraph{Timers}
A first glance at the Lua reference manual indicates that standard Lua offers very limited facilities for time measurement. Lua allows for second-based timestamps as the finest granularity, which may be sufficient for the intended use of Lua as an extension language, but becomes a problem if one wants to implement real time systems fully in Lua. Ideally, at least millisecond granularity should be available.

\subsection{Comparison to other scripting languages}

http://flux242.blogspot.no/2013/05/python-vs-perl-vs-lua-speed-comparison.html

\paragraph{Python}
http://lua-users.org/wiki/LuaVersusPython

\subsection{Comparison to Java}
\label{sec:lua_java}

\subsection{Why not C?}

\section{Similar work}

\subsection{Reactive Blocks}

\subsection{title}